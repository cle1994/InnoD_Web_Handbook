# Javascript (JS)

ES2015 (previously ES6) and beyond makes javascript so much easier
to work with :+1: Seriously, it's a godsend for web developers.
This will go over some cool things in ES2015 and ES7+
Everything ES7+ (ES7, ES8, etc.) are still very experimental, so
their APIs will probably change as time goes on.

*ES2015 is still not supported by most browsers, or not completely
supported. At the time of writing this, even Chrome doesn't fully
support ES2015. You'll need to use Babel to transpile
your ES2015 code to ES5 (most supported version of Javascript).
Babel will be for another time though.*

**Quick Jump**

* [Arrow Functions](7-es2015.md#arrow)
* [Underscore](7-es2015.md#underscore)
* [Classes](7-es2015.md#classes)
* [Template Strinsg](7-es2015.md#template)
* [Default](7-es2015.md#default)
* [Rest](7-es2015.md#rest)
* [Spread](7-es2015.md#spread)
* [Variable Constructs](7-es2015.md#constructs)
* [for...of](7-es2015.md#of)
* [for...in](7-es2015.md#in)
* [Promises](7-es2015.md#promises)

<a name="arrow"></a>
# Arrow Functions (and lexical scope)
If you don't understand scope, go understand it first and come back.
Arrow functions aren't just used a shorthand for a function because
you're too lazy to type.

```js
let kitty = {
  age: 2,
  color: 'brown',
  name: 'Kitty',
  siblings: ['Perry', 'Meow'],
  printSiblings: function() {
    this.siblings.forEach(function(cat) {
      console.log(`${this.name} has sibling ${cat}`); 
    });
  }
};
```
*The backtick syntax is a template string, read on to learn more.*

You would think that the output is

```js
// Kitty has sibling Perry
// Kitty has sibling Meow
```

But what you get is

```js
// undefined has sibling Perry
// undefined has sibling Meow
```

This is where scope is important, because you are using a function
to as a callback to `.forEach` it creates it's own scope which
doesn't have a property `name`. To easily fix this we can use arrow
functions

```js
kitty.printSiblings = function() {
  this.siblings.forEach((cat) => {
    console.log(`${this.name} has sibling ${cat}`);
  });
};
```

This will give the output you're expecting because arrow functions
have the same scope as their surrounding code/function (functions
create scope in Javascript).

Arrow functions can also be used if you just like the way they look.
Just remember they don't create a scope, they are bound to the scope
of their surrounding code.

```js
const animal = (name, scientificName) => {
  console.log(`The scientific name of ${name} is ${scientificName}`);
};
```

<a name="underscore"></a>
# Underscore (Not to be confused with Underscore.js or Lodash.js)
The underscore in many languages is used to explictly state you do
not care about using the return of a function call. It's just better
style to assign the return to something instead of just pretending it
doesn't return anything.

```js
function hello(name) {
  console.log(`Hello ${name}!`);
  return true;
}
```

Let's say you don't care about what hello returns, you just want to
call it and log `Hello ${name}!`
```js
hello("Perry");
```

This would work just fine, but you're effectively saying hello
doesn't return anything. It's hard for future engineers looking 
at your code to truly understand the function `hello`. In this case
you can just do
```js
let _ = hello("Perry");
```

Now we know hello returns something, we just don't care what it 
returns. If someone is curious at this point they can go and look
up the function definition.

You can also use the underscore in functions when you don't care
about what the value is.

```js
let cats = ['perry', 'kitty', 'meow'];
cats.forEach(_ => {
  console.log('Cat');
});
```

<a name="classes"></a>
# Classes

<a name="template"></a>
# Template Strings

<a name="default"></a>
# Default params

<a name="rest"></a>
# Rest params

<a name="spread"></a>
# Spread params

<a name="constructs"></a>
# Variable Constructs

<a name="of"></a>
# for...of

<a name="in"></a>
# for...in

<a name="promises"></a>
# Promises

